"""
Module: System
    This module shall be used to implement subclasses of system1D. It wraps all information needed and generated by a simulation.
"""

import numpy as np
import os
import warnings
from numbers import Number
from typing import Iterable, NoReturn, List

import pandas as pd
import scipy.constants as const
from tqdm.notebook import tqdm

pd.options.mode.use_inf_as_na = True
# Typing
from ensembler.util.basic_class import super_baseClass
import ensembler.util.ensemblerTypes as ensemblerTypes

_samplerCls = ensemblerTypes.sampler
_conditionCls = ensemblerTypes.condition
_potentialCls = ensemblerTypes.potential

from ensembler.util import dataStructure as data

from ensembler.samplers.newtonian import newtonianSampler
from ensembler.samplers import stochastic
from ensembler.potentials.biased_potentials.biasOneD import metadynamicsPotential as metadynamicsPotential1D
from ensembler.potentials.biased_potentials.biasTwoD import metadynamicsPotential as metadynamicsPotential2D


class system(super_baseClass):
    # static attributes
    name = "system"
    state = data.basicState

    """
    Attributes:
    """

    ##POTENTIAL CLASS
    @property
    def potential(self) -> _potentialCls:
        return self.m_potential

    @potential.setter
    def potential(self, potential: _potentialCls):
        # if(issubclass(potential.__class__, _potentialCls)):
        self.m_potential = potential
        # else:
        #     raise ValueError("Potential needs to be a subclass of potential")

    @property
    def sampler(self) -> _samplerCls:
        return self.m_integrator

    @sampler.setter
    def sampler(self, integrator: _samplerCls):
        self.m_integrator = integrator

    @property
    def conditions(self) -> List[_conditionCls]:
        return self.m_conditions

    @conditions.setter
    def conditions(self, conditions: List[_conditionCls]):
        if (isinstance(conditions,
                       List)):  # and all([issubclass(condition.__class__, _conditionCls) for condition in conditions])):
            self.m_conditions = conditions
        else:
            raise ValueError("Conditions needs to be a List of objs, that are a subclass of _conditionCls")

    def __init__(self, potential: _potentialCls, sampler: _samplerCls, conditions: Iterable[_conditionCls] = [],
                 temperature: Number = 298.0, start_position: (Iterable[Number] or Number) = None, mass: Number = 1,
                 verbose: bool = True) -> NoReturn:
        """
            The system class is wrapping all components needed for a simulation.
            It can be used as the control unit for executing a simulation (simulate) and also to manage the generated data or input data.

        Parameters
        ----------
        potential : _potentialCls
            gives the potential function to be explored/sampled
        sampler : _samplerCls
            gives the method of choice to sample/explore the potential function
        conditions : Iterable[_conditionCls], optional
            apply the given conditions to the systems in a preset (tau) step iteration
        temperature : float, optional
            temperature of the system
        start_position : float, optional
            starting position of the system during the simulation
        mass : float, optional
            mass of the single particle
        verbose : bool, optional
            I can tell you a long iterative story...
        """

        ################################
        # Declare Attributes
        #################################

        ##Physical parameters
        self.temperature = temperature
        self.mass = mass # for one particle systems!!!!
        self.nparticles = 1  # Todo: adapt it to be multiple particles

        # Output
        self.currentState = self.state(**{key: np.nan for key in self.state.__dict__["_fields"]})
        self.trajectory= pd.DataFrame(columns=list(self.state.__dict__["_fields"]))

        # tmpvars - private:
        self._currentTotE: (Number) = np.nan
        self._currentTotPot: (Number) = np.nan
        self._currentTotKin: (Number) = np.nan
        self._currentPosition: (Number or Iterable[Number]) = np.nan
        self._currentVelocities: (Number or Iterable[Number]) = np.nan
        self._currentForce: (Number or Iterable[Number]) = np.nan
        self._currentTemperature: (Number or Iterable[Number]) = np.nan

        # BUILD System
        ## Fundamental Parts:
        self.m_potential = potential
        self.m_integrator = sampler
        self.m_conditions = conditions

        ## set dim
        if (potential.constants[potential.nDim] < 1 and isinstance(start_position, Iterable) and all(
                [isinstance(pos, Number) for pos in start_position])):  # one  state system.
            self.nDim = len(start_position)
            self.potential.constants.update({potential.nDim: self.nDim})
        elif (potential.constants[potential.nDim] > 0):
            self.nDim = potential.constants[potential.nDim]
        else:
            raise IOError(
                "Could not estimate the disered Dimensionality as potential dim was <1 and no initial position was given.")
        self.mass = mass

        ###is the potential a state dependent one? - needed for initial pos.
        if (hasattr(potential, "nStates")):
            self.nStates = potential.constants[potential.nStates]
            if (hasattr(potential, "states_coupled")):  # does each state get the same position?
                self.states_coupled = potential.states_coupled
            else:
                self.states_coupled = True  # Todo: is this a good Idea?
        else:
            self.nstates = 1

        # PREPARE THE SYSTEM
        # Only init velocities, if the samplers uses them
        if (issubclass(sampler.__class__, (newtonianSampler, stochastic.langevinIntegrator))):
            init_velocity = True
        else:
            init_velocity = False
        self.initialise(withdraw_Traj=True, init_position=True, init_velocity=init_velocity,
                        set_initial_position=start_position)

        ##check if system should be coupled to conditions:

        # update for metadynamics simulation - local elevation bias is like a condition/potential hybrid.

        if isinstance(self.potential, metadynamicsPotential1D) or isinstance(self.potential, metadynamicsPotential2D):
            self.conditions.append(self.potential)

        for condition in self.conditions:
            if (not hasattr(condition, "system")):
                condition.coupleSystem(self)
            else:
                # warnings.warn("Decoupling system and coupling it again!")
                condition.coupleSystem(self)
            if (not hasattr(condition, "dt") and hasattr(self.sampler, "dt")):
                condition.dt = self.sampler.dt
            else:
                condition.dt = 1

        self.verbose = verbose

    """
        Initialisation
    """

    def initialise(self, withdraw_Traj: bool = True, init_position: bool = True, init_velocity: bool = True,
                   set_initial_position=None):
        if (withdraw_Traj):
            self.trajectory = pd.DataFrame(columns=list(self.state.__dict__["_fields"]))

        if (init_position):
            self._init_position(initial_position=set_initial_position)

        # Try to init the force
        try:
            self._currentForce = self.potential.force(self.initial_position)  # initialise forces!    #todo!
        except:
            warnings.warn("Could not initialize the force of the potential? Check if you need it!")

        if (init_velocity):
            self._init_velocities()

        # set initial Temperature
        self._currentTemperature = self.temperature

        # update current state
        self.step = 0
        self.updateSystemProperties()
        self.updateCurrentState()
        self.trajectory = self.trajectory.append(self.currentState._asdict(), ignore_index=True)

    def _init_position(self, initial_position=None):
        if (isinstance(initial_position, type(None))):
            self.initial_position = self.randomPos()
        elif (isinstance(initial_position, (Number, Iterable))):
            self.initial_position = initial_position
        else:
            raise Exception("did not understand the initial position!")
        self._currentPosition = self.initial_position

        self.updateCurrentState()
        return self.initial_position

    def _init_velocities(self) -> NoReturn:
        if (self.nStates > 1):
            self._currentVelocities = [[self._gen_rand_vel() for dim in range(self.nDim)] for s in
                                       range(self.nStates)] if (self.nDim > 1) else [self._gen_rand_vel() for state in
                                                                                     range(self.nStates)]
        else:
            self._currentVelocities = [self._gen_rand_vel() for dim in range(self.nDim)] if (
                    self.nDim > 1) else self._gen_rand_vel()

        self.veltemp = self.mass / const.gas_constant / 1000.0 * np.linalg.norm(self._currentVelocities) ** 2  # t

        self.updateCurrentState()
        return self._currentVelocities

    def _gen_rand_vel(self) -> float:
        return np.sqrt(const.gas_constant / 1000.0 * self.temperature / self.mass) * np.random.normal()

    def randomPos(self) -> (np.array or np.float):
        """uncoupled states
        if(self.nStates > 1):
            return [np.subtract(np.multiply(np.random.rand(self.nDim),20),10) for state in range(self.nStates)]
        else:
        """
        random_pos = np.squeeze(np.array(np.subtract(np.multiply(np.random.rand(self.nDim), 20), 10)))
        if (len(random_pos.shape) == 0):
            return np.float(random_pos)
        else:
            return random_pos

    """
        Update
    """

    def totKin(self) -> (Iterable[Number] or Number or None):
        # Todo: more efficient if?
        if (self.nDim == 1 and isinstance(self._currentVelocities, Number) and not np.isnan(self._currentVelocities)):
            return 0.5 * self.mass * np.square(np.linalg.norm(self._currentVelocities))
        elif (self.nDim > 1 and isinstance(self._currentVelocities, Iterable) and all(
                [isinstance(x, Number) and not np.isnan(x) for x in self._currentVelocities])):
            return np.sum(0.5 * self.mass * np.square(np.linalg.norm(self._currentVelocities)))
        else:
            return np.nan

    def totPot(self) -> (Iterable[Number] or Number or None):
        return self.potential.ene(self._currentPosition)

    def updateSystemProperties(self) -> NoReturn:
        self._updateEne()
        self._updateTemp()

    def updateCurrentState(self) -> NoReturn:
        self.currentState = self.state(self._currentPosition, self._currentTemperature,
                                       self._currentTotE, self._currentTotPot, self._currentTotKin,
                                       self._currentForce, self._currentVelocities)

    def _update_CurrVars(self) -> NoReturn:
        self._currentPosition = self.currentState.position
        self._currentTemperature = self.currentState.temperature
        self._currentTotE = self.currentState.totEnergy
        self._currentTotPot = self.currentState.totPotEnergy
        self._currentTotKin = self.currentState.totKinEnergy
        self._currentForce = self.currentState.dhdpos
        self._currentVelocities = self.currentState.velocity

    def _updateTemp(self) -> NoReturn:
        """ this looks like a thermostat like thing! not implemented!@ TODO calc velocity from speed"""
        pass
        #self._currentTemperature = self._currentTemperature

    def _updateEne(self) -> NoReturn:
        self._currentTotPot = self.totPot()
        self._currentTotKin = self.totKin()
        self._currentTotE = self._currentTotPot if (np.isnan(self._currentTotKin)) else np.add(self._currentTotKin,
                                                                                               self._currentTotPot)

    def _update_current_vars_from_current_state(self):
        self._currentPosition = self.currentState.position
        self._currentTemperature = self.currentState.temperature
        self._currentTotE = self.currentState.totEnergy
        self._currentTotPot = self.currentState.totPotEnergy
        self._currentTotKin = self.state.totKinEnergy
        self._currentForce = self.currentState.dhdpos
        self._currentVelocities = self.currentState.velocity

    """
        Functionality
    """

    def simulate(self, steps: int, withdrawTraj: bool = False, save_every_state: int = 1, initSystem: bool = False,
                 verbosity: bool = True,     _progress_bar_prefix:str="") -> state:

        if (withdrawTraj):
            self.trajectory: pd.DataFrame = pd.DataFrame(columns=list(self.state.__dict__["_fields"]))
            self.trajectory = self.trajectory.append(self.currentState._asdict(), ignore_index=True)

        if (initSystem):
            self._init_position()
            self._init_velocities()

        self.updateCurrentState()
        self.updateSystemProperties()

        # progressBar or no ProgressBar
        if (verbosity):
            iteration_queue = tqdm(range(steps), desc=_progress_bar_prefix+" Simulation: ", mininterval=1.0, leave=verbosity)
        else:
            iteration_queue = range(steps)

        # Simulation loop
        for self.step in iteration_queue:

            # Do one simulation Step.
            self.propagate()

            # Apply Restraints, Constraints ...
            self.applyConditions()

            # Calc new Energy&and other system properties
            self.updateSystemProperties()

            # Set new State
            self.updateCurrentState()

            if (self.step % save_every_state == 0 and self.step != steps - 1):
                self.trajectory = self.trajectory.append(self.currentState._asdict(), ignore_index=True)

            # update for metadynamics simulation TODO: remove if changes accepted
            # if isinstance(self.potential , metadynamicsPotential1D) or isinstance(self.potential , metadynamicsPotential2D):
            #    self.potential.check_for_metastep(self._currentPosition)

        self.trajectory = self.trajectory.append(self.currentState._asdict(), ignore_index=True)

        return self.currentState

    def propagate(self) -> NoReturn:
        self._currentPosition, self._currentVelocities, self._currentForce = self.sampler.step(self)

    def applyConditions(self) -> NoReturn:
        for aditional in self.conditions:
            aditional.apply_coupled()

    def append_state(self, newPosition, newVelocity, newForces) -> NoReturn:
        self._currentPosition = newPosition
        self._currentVelocities = newVelocity
        self._currentForce = newForces

        self._updateTemp()
        self._updateEne()
        self.updateCurrentState()

        self.trajectory = self.trajectory.append(self.currentState._asdict(), ignore_index=True)

    def revertStep(self) -> NoReturn:
        self.currentState = self.trajectory.iloc[-2]
        self._update_current_vars_from_current_state()
        return

    def _update_state_from_traj(self) -> NoReturn:
        self.currentState = self.state(**self.trajectory.iloc[-1].to_dict())
        self._update_current_vars_from_current_state()
        return

    """
        Getter
    """

    # Getters
    def getTotPot(self) -> (Iterable[Number] or Number or None):
        return self._currentTotPot

    def getTotEnergy(self) -> (Iterable[Number] or Number or None):
        return self._currentTotE

    def getCurrentState(self) -> state:
        return self.currentState

    def getTrajectory(self) -> pd.DataFrame:
        return self.trajectory

    # writing out
    def writeTrajectory(self, out_path: str) -> str:
        if (not os.path.exists(os.path.dirname(out_path))):
            raise Exception("Could not find output folder: " + os.path.dirname(out_path))
        self.trajectory.to_csv(out_path, header=True)
        return out_path

    # Setters
    def set_position(self, position):
        self._currentPosition = position
        if (len(self.trajectory) == 0):
            self.initial_position = self._currentPosition
        self._updateEne()
        self.updateCurrentState()

    def set_velocities(self, velocities):
        self._currentVelocities = velocities
        self._updateEne()
        self.updateCurrentState()

    def set_current_state(self, currentPosition: (Number or Iterable), currentVelocities: (Number or Iterable) = 0,
                          currentForce: (Number or Iterable) = 0, currentTemperature: Number = 298):
        self._currentPosition = currentPosition
        self._currentForce = currentForce
        self._currentVelocities = currentVelocities
        self._currentTemperature = currentTemperature
        self.currentState = self.state(self._currentPosition, self._currentTemperature, np.nan, np.nan, np.nan, np.nan,
                                       np.nan)

        self._updateEne()
        self.updateCurrentState()

    def set_Temperature(self, temperature):
        """ this looks like a thermostat like thing! not implemented!@"""
        self.temperature = temperature
        self._currentTemperature = temperature
        self._updateEne()
