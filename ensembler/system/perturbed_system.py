"""
Module: System
    This module shall be used to implement subclasses of system. It wraps all information needed and generated by a simulation.
"""


from numbers import Number
from typing import Iterable, NoReturn

import numpy as np
import pandas as pd

pd.options.mode.use_inf_as_na = True

from ensembler.util import dataStructure as data
from ensembler.util import ensemblerTypes as ensemblerTypes

_integratorCls = ensemblerTypes.samplerCls
_conditionCls = ensemblerTypes.conditionCls

from ensembler.potentials._basicPotentials import _potential1DClsPerturbed as _perturbedPotentialCls
from ensembler.system.basic_system import system


class perturbedSystem(system):
    """
    
    """
    name = "perturbed system"
    # Lambda Dependend Settings
    state = data.lambdaState
    currentState: data.lambdaState
    potential: _perturbedPotentialCls

    # current lambda
    _currentLambda: float = np.nan
    _currentdHdLambda: float = np.nan

    """
    Attributes
    """
    @property
    def lam(self)->Number:
        return self._currentLambda

    @lam.setter
    def lam(self, lam:Number):
        self._currentLambda = lam
        self.potential.set_lambda(lam=self._currentLambda)
        self._updateEne()

    def set_lam(self, lam: float):
        self.lam = lam

    """
    Magic
    """
    def __init__(self, potential: _perturbedPotentialCls, sampler: _integratorCls,
                 conditions: Iterable[_conditionCls] = [],
                 temperature: float = 298.0, start_position: (Iterable[Number] or float) = None, lam: float = 0.0):
        """
            __init__
                construct a eds-System that can be used to manage a simulation.

        Parameters
        ----------
        potential:  pot.envelopedPotential, optional
            potential function class to be explored by sampling
        sampler: sampler, optional
            sampling method, that allows exploring the potential function
        conditions: Iterable[condition], optional
            conditions that shall be applied to the system.
        temperature: float, optional
            The temperature of the system (default: 298K)
        start_position:
            starting position for the simulation and setup of the system.
        lam: Number, optional
            the value of the copuling lambda
        """

        self._currentLambda = lam

        super().__init__(potential=potential, sampler=sampler, conditions=conditions, temperature=temperature,
                         start_position=start_position)
        self.set_lam(lam)

    """
    Overwrite Functions to adapt to EDS
    """
    def set_current_state(self, currentPosition: (Number or Iterable), currentLambda: (Number or Iterable),
                          currentVelocities: (Number or Iterable) = 0, currentdHdLam: (Number or Iterable) = 0,
                          currentForce: (Number or Iterable) = 0, currentTemperature: Number = 298):
        """
            set_current_state
                set s the current state to the given variables.

        Parameters
        ----------
        currentPosition: Union[Number, Iterable[Number]]
            The new Position
        currentVelocities: Union[Number, Iterable[Number]],
            The new Velocities
        currentForce: Union[Number, Iterable[Number]],
            The new Forces of the system
        current_lam: Union[Number, Iterable[Number]],
            The new lambda value
        current_dHdLam: Union[Number, Iterable[Number]],
            The new dHdLam
        currentTemperature: Union[Number, Iterable[Number]],
            the new temperature.
        """
        self._currentPosition = currentPosition
        self._currentForce = currentForce
        self._currentVelocities = currentVelocities
        self._currentTemperature = currentTemperature

        self._updateEne()
        self._update_dHdLambda()
        self.updateCurrentState()

    def updateSystemProperties(self) -> NoReturn:
        """
            updateSystemProperties
                update all system properties
        """
        self._updateEne()
        self._updateTemp()
        self._update_dHdLambda()

    def updateCurrentState(self):
        """
        updateCurrentState
                This function updates the current state from the _current Variables.

        """
        self._currentState = self.state(position=self._currentPosition, temperature=self._currentTemperature,
                                        total_system_energy=self._currentTotE,
                                        total_potential_energy=self._currentTotPot, total_kinetic_energy=self._currentTotKin,
                                        dhdpos=self._currentForce, velocity=self._currentVelocities,
                                        lam=self._currentLambda, dhdlam=self._currentdHdLambda)

    def append_state(self, newPosition:Number, newVelocity:Number, newForces:Number, newLambda:Number) -> NoReturn:
        """
            append_state
                Append a new state to the trajectory.

        Parameters
        ----------
        newPosition: Union[Number, Iterable[Number]]
            new position for the system
        newVelocity: Union[Number, Iterable[Number]]
            new velocity for the system
        newForces: Union[Number, Iterable[Number]]
            new forces for the system
        newLambda: Number
            new lambda

        """
        self._currentPosition = newPosition
        self._currentVelocities = newVelocity
        self._currentForce = newForces
        self._currentLambda = newLambda

        self._updateTemp()
        self._updateEne()
        self._update_dHdLambda()
        self.updateCurrentState()

        self._trajectory = self._trajectory.append(self.current_state._asdict(), ignore_index=True)

    """
    Functionality
    """
    def _update_dHdLambda(self) -> Number:
        """
            _update_dHdlambda
                update the current dHdLambda value

        Returns
        -------
        Number
            dHdlambda

        """
        self._currentdHdLambda = self.potential.dvdlam(self._currentPosition)
        self.updateCurrentState()
        return self._currentdHdLambda
